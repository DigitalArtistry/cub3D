display/camera.c:	olddirx = display->dirx;
display/camera.c:	display->dirx = display->dirx * cos(display->rotspeed * i)
display/camera.c:		- display->diry * sin(display->rotspeed * i);
display/camera.c:	display->diry = olddirx * sin(display->rotspeed * i)
display/camera.c:		+ display->diry * cos(display->rotspeed * i);
display/camera.c:	oldplanex = display->planex;
display/camera.c:	display->planex = display->planex * cos(display->rotspeed * i)
display/camera.c:		- display->planey * sin(display->rotspeed * i);
display/camera.c:	display->planey = oldplanex * sin(display->rotspeed * i)
display/camera.c:		+ display->planey * cos(display->rotspeed * i);
display/camera.c:		tmpy = display->player.y + display->planey * display->pspeed;
display/camera.c:		tmpx = display->player.x + display->planex * display->pspeed;
display/camera.c:		tmpx = display->player.x - ((display->pspeed * display->dirx));
display/camera.c:		tmpy = display->player.y - ((display->pspeed * display->diry));
display/camera.c:		tmpx = display->player.x + ((display->pspeed * display->dirx));
display/camera.c:		tmpy = display->player.y + ((display->pspeed * display->diry));
display/camera.c:		tmpy = display->player.y - display->planey * display->pspeed;
display/camera.c:		tmpx = display->player.x - display->planex * display->pspeed;
display/camera.c:	if (display->map[(int)display->player.y][(int)tmpx] != '1')
display/camera.c:		display->player.x = tmpx;
display/camera.c:	if (display->map[(int)tmpy][(int)display->player.x] != '1')
display/camera.c:		display->player.y = tmpy;
display/draw.c:	if (y >= display->r2 || x >= display->r1 || x < 0 \
display/draw.c:	dest = display->pxl + display->s_line * y + x * (display->bpp / 8); // Modification de la couleur de la valeur correspondante au pixel dans l'adresse mlx
display/draw.c:	while (++y < display->startline)   // draw du plafond en couleur rgb
display/draw.c:			colortoint(display->rgbceiling[0],
display/draw.c:			display->rgbceiling[1], display->rgbceiling[2]));
display/draw.c:	while (y < display->endline)
display/draw.c:		display->texywall = (int)display->texpos &
display/draw.c:		(display->heighttext[display->textnum] - 1);
display/draw.c:		display->texpos += display->stepdraw;
display/draw.c:		display->color = *(unsigned int *)(display->ptr[display->textnum] +         // Recuperation de la couleur de la texture correspondante (tex_x / tex_y)
display/draw.c:		display->s_line2[display->textnum] * display->texywall +
display/draw.c:		display->texxwall * (display->bpp2[display->textnum] / 8));
display/draw.c:		put_pxl(display, x, y, display->color);
display/draw.c:	while (++y < display->r2)
display/draw.c:			colortoint(display->rgbfloor[0],
display/draw.c:			display->rgbfloor[1], display->rgbfloor[2]));
display/draw.c:	display->texxwall = (int)(display->wallx *
display/draw.c:	(double)(display->widthtext[display->textnum]));
display/draw.c:	if (display->spritecounted > 0)
display/draw.c:		display->zbuffer[x] = display->perwalldist;
display/draw.c:	if (display->side == 0 && display->d.x > 0)
display/draw.c:		display->texxwall = display->widthtext[display->textnum]
display/draw.c:		- display->texxwall - 1;
display/draw.c:	if (display->side == 1 && display->d.y < 0)
display/draw.c:		display->texxwall = display->widthtext[display->textnum]
display/draw.c:		- display->texxwall - 1;
display/draw.c:	display->stepdraw = 1.0 * display->heighttext[display->textnum]
display/draw.c:	/ display->lineheight;
display/draw.c:	display->texpos = (display->startline - display->r2
display/draw.c:	/ 2 + display->lineheight / 2) * display->stepdraw;
display/drawsprite.c:	display->onspritex = display->spritex[index] - display->player.x + 0.5;
display/drawsprite.c:	display->onspritey = display->spritey[index] - display->player.y + 0.5;
display/drawsprite.c:	display->invdet = 1.0 / (display->planex * display->diry
display/drawsprite.c:	- display->dirx * display->planey);
display/drawsprite.c:	display->transformx = display->invdet *
display/drawsprite.c:	(display->diry * display->onspritex - display->dirx * display->onspritey);
display/drawsprite.c:	display->transformy = display->invdet * (-display->planey *
display/drawsprite.c:	display->onspritex + display->planex * display->onspritey);
display/drawsprite.c:	display->spritescreenx = (int)((display->r1 / 2)
display/drawsprite.c:	* (1 + display->transformx / display->transformy));
display/drawsprite.c:	display->spriteheight = abs((int)(display->r2 / (display->transformy)));
display/drawsprite.c:	display->spritewidth = abs((int)(display->r2 / (display->transformy)));
display/drawsprite.c:	display->drawstarty = -display->spriteheight / 2 + display->r2 / 2;
display/drawsprite.c:	if (display->drawstarty < 0)
display/drawsprite.c:		display->drawstarty = 0;
display/drawsprite.c:	display->drawendy = display->spriteheight / 2 + display->r2 / 2;
display/drawsprite.c:	if (display->drawendy >= display->r2)
display/drawsprite.c:		display->drawendy = display->r2 - 1;
display/drawsprite.c:	display->drawstartx = -display->spritewidth / 2 + display->spritescreenx;
display/drawsprite.c:	if (display->drawstartx < 0)
display/drawsprite.c:		display->drawstartx = 0;
display/drawsprite.c:	display->drawendx = display->spritewidth / 2 + display->spritescreenx;
display/drawsprite.c:	if (display->drawendx >= display->r1)
display/drawsprite.c:		display->drawendx = display->r1 - 1;
display/drawsprite.c:	display->y = display->drawstarty;
display/drawsprite.c:	while (display->y < display->drawendy)
display/drawsprite.c:		display->dsprite = display->y * 256 - display->r2
display/drawsprite.c:		* 128 + display->spriteheight * 128;
display/drawsprite.c:		display->texy = ((display->dsprite *
display/drawsprite.c:		display->heighttext[5])
display/drawsprite.c:		/ display->spriteheight) / 256;
display/drawsprite.c:		display->colorsprite = *(unsigned int*)
display/drawsprite.c:		(display->ptr[5]
display/drawsprite.c:		+ display->s_line2[5]
display/drawsprite.c:		* display->texy + display->texx *
display/drawsprite.c:		(display->bpp2[5] / 8));
display/drawsprite.c:		if ((display->colorsprite & 0x00FFFFFF) != 0 &&
display/drawsprite.c:		display->y < display->r2 && display->stripe < display->r1)
display/drawsprite.c:			put_pxl(display, display->stripe, display->y, display->colorsprite);
display/drawsprite.c:		display->y++;
display/drawsprite.c:	while (index < display->spritecounted)
display/drawsprite.c:		display->stripe = display->drawstartx;
display/drawsprite.c:		while (display->stripe < display->drawendx)
display/drawsprite.c:			display->texx = (int)(256 * (display->stripe -
display/drawsprite.c:			(-display->spritewidth / 2 + display->spritescreenx)) *
display/drawsprite.c:			display->widthtext[5]
display/drawsprite.c:			/ display->spritewidth) / 256;
display/drawsprite.c:			if (display->transformy > 0.1 && display->stripe > 0
display/drawsprite.c:			&& display->stripe < display->r1
display/drawsprite.c:			&& display->transformy < display->zbuffer[display->stripe])
display/drawsprite.c:			display->stripe++;
display/drawsprite.c:	while (index < display->spritecounted)
display/drawsprite.c:		display->spritedist[index] = ((display->player.x -
display/drawsprite.c:		display->spritex[index]) *
display/drawsprite.c:		(display->player.x - display->spritex[index]) +
display/drawsprite.c:		(display->player.y - display->spritey[index]) *
display/drawsprite.c:		(display->player.y - display->spritey[index]));
display/drawsprite.c:	while (index < display->spritecounted)
display/drawsprite.c:		if (display->spritedist[index - 1] < display->spritedist[index])
display/initdisplay.c:	if (display->bmp == 1)
display/initdisplay.c:	mlx_do_key_autorepeatoff(display->mlx_ptr);
display/initdisplay.c:	mlx_hook(display->mlx_win, 2, 1L, ft_key_hit, display);
display/initdisplay.c:	mlx_hook(display->mlx_win, 3, 2L, ft_key_release, display);
display/initdisplay.c:	mlx_hook(display->mlx_win, CLOSERED, 1L << 17, closebyredbutton, display);
display/initdisplay.c:	mlx_hook(display->mlx_win, 12, 0, ft_expose, display);
display/initdisplay.c:	mlx_loop_hook(display->mlx_ptr, key_loop, display);
display/initdisplay.c:	mlx_loop(display->mlx_ptr);
display/initdisplay.c:	display->mlx_ptr = mlx_init();
display/initdisplay.c:	display->img = mlx_new_image(display->mlx_ptr, display->r1, display->r2);
display/initdisplay.c:	display->pxl = mlx_get_data_addr(display->img,
display/initdisplay.c:			&(display->bpp), &(display->s_line),
display/initdisplay.c:			&(display->ed));
display/initdisplay.c:	display->last_frame = clock();
display/initdisplay.c:	display->next_frame = 0;
display/initdisplay.c:	if (display->bmp == 0)
display/initdisplay.c:		if ((display->mlx_win = mlx_new_window(display->mlx_ptr, display->r1,
display/initdisplay.c:						display->r2, "42 Cub3D")) == NULL)
display/initdisplay.c:			display->initsuccess = 1;
display/initdisplay.c:	if (display->bmp == 0)
display/initdisplay.c:		mlx_put_image_to_window(display->mlx_ptr,
display/initdisplay.c:			display->mlx_win, display->img, 0, 0);
display/initdisplay.c:	if (display->bmp == 0)
display/initdisplay.c:	if (display->keyboard[ESC] || display->keyboard[ROT_LEFT]
display/initdisplay.c:	|| display->keyboard[ROT_RIGHT] || display->keyboard[RIGHT]
display/initdisplay.c:	|| display->keyboard[LEFT] || display->keyboard[BACK]
display/initdisplay.c:	|| display->keyboard[ADVANCE])
display/initdisplay.c:	if (display->spritecounted != 0)
display/initdisplay.c:	mlx_put_image_to_window(display->mlx_ptr,
display/initdisplay.c:	display->mlx_win, display->img, 0, 0);
display/initdisplay.c:	display->bpp = 0;
display/initdisplay.c:	display->s_line = 0;
display/initdisplay.c:	display->pspeed = 0.1;
display/initdisplay.c:	display->rotspeed = 0.04;
display/initdisplay.c:	display->index = 0;
display/initdisplay.c:	display->r1 = parse->r1;
display/initdisplay.c:	display->r2 = parse->r2;
display/initdisplay.c:	display->keyboard[BACK] = 0;
display/initdisplay.c:	display->keyboard[RED_BUTTON] = 0;
display/initdisplay.c:	display->keyboard[ROT_RIGHT] = 0;
display/initdisplay.c:	display->keyboard[ESC] = 0;
display/initdisplay.c:	display->keyboard[LEFT] = 0;
display/initdisplay.c:	display->keyboard[RIGHT] = 0;
display/initdisplay.c:	display->keyboard[ROT_LEFT] = 0;
display/initdisplay.c:	display->keyboard[ADVANCE] = 0;
display/initdisplay.c:	mlx_put_image_to_window(display->mlx_ptr,
display/initdisplay.c:	display->mlx_win, display->img, 0, 0);
display/keyboard.c:	display->keyboard[keycode] = 1;
display/keyboard.c:	display->keyboard[keycode] = 0;
display/keyboard.c:	if (display->keyboard[ADVANCE])
display/keyboard.c:	if (display->keyboard[BACK])
display/keyboard.c:	if (display->keyboard[LEFT])
display/keyboard.c:	if (display->keyboard[RIGHT])
display/keyboard.c:	if (display->keyboard[ROT_RIGHT])
display/keyboard.c:	if (display->keyboard[ROT_LEFT])
display/keyboard.c:	if (display->keyboard[ESC] || display->keyboard[RED_BUTTON])
display/keyboard.c:	display->keyboard[RED_BUTTON] = 1;
display/loadsprites.c:	display->spritecounted = 0;
display/loadsprites.c:	if (display->spritecounted != 0)
display/loadsprites.c:		if ((display->sprite = mlx_xpm_file_to_image(display->mlx_ptr,
display/loadsprites.c:			display->spritepwd, &display->widthtext[5],
display/loadsprites.c:			&display->heighttext[5])))
display/loadsprites.c:			display->ptr[5] = mlx_get_data_addr(display->sprite,
display/loadsprites.c:			&(display->bpp2[5]), &(display->s_line2[5]), &(display->ed2[5]));
display/loadsprites.c:		display->spritex = malloc(display->spritecounted * sizeof(int));
display/loadsprites.c:		display->spritey = malloc(display->spritecounted * sizeof(int));
display/loadsprites.c:		display->spritedist = malloc(display->spritecounted * sizeof(double));
display/loadsprites.c:		display->zbuffer = malloc((display->r1 + 1) * sizeof(double));
display/loadsprites.c:	display->indexdey = 0;
display/loadsprites.c:	display->indexdex = 0;
display/loadsprites.c:	while (display->indexdex < display->mapy)
display/loadsprites.c:		spritenum = display->map[display->indexdex][display->indexdey];
display/loadsprites.c:		display->indexdey++;
display/loadsprites.c:		if (display->indexdey == display->mapx)
display/loadsprites.c:			display->indexdey = 0;
display/loadsprites.c:			display->indexdex++;
display/loadsprites.c:	display->spritecounted = sprites;
display/loadsprites.c:	if (display->spritecounted != 0)
display/loadsprites.c:		display->spritex[sprites] = display->indexdey;
display/loadsprites.c:		display->spritey[sprites] = display->indexdex;
display/loadtextures.c:	if ((display->text_no = mlx_xpm_file_to_image(display->mlx_ptr,
display/loadtextures.c:	display->north, &display->widthtext[0], &display->heighttext[0])))
display/loadtextures.c:		display->ptr[0] = mlx_get_data_addr(display->text_no,
display/loadtextures.c:		&(display->bpp2[0]), &(display->s_line2[0]), &(display->ed2[0]));
display/loadtextures.c:	if ((display->text_so = mlx_xpm_file_to_image(display->mlx_ptr,
display/loadtextures.c:	display->south, &display->widthtext[1], &display->heighttext[1])))
display/loadtextures.c:		display->ptr[1] = mlx_get_data_addr(display->text_so,
display/loadtextures.c:		&(display->bpp2[1]), &(display->s_line2[1]), &(display->ed2[1]));
display/loadtextures.c:	if ((display->text_we = mlx_xpm_file_to_image(display->mlx_ptr,
display/loadtextures.c:	display->west, &display->widthtext[2], &display->heighttext[2])))
display/loadtextures.c:		display->ptr[2] = mlx_get_data_addr(display->text_we,
display/loadtextures.c:		&(display->bpp2[2]), &(display->s_line2[2]), &(display->ed2[2]));
display/loadtextures.c:	if ((display->text_ea = mlx_xpm_file_to_image(display->mlx_ptr,
display/loadtextures.c:	display->east, &display->widthtext[3], &display->heighttext[3])))
display/loadtextures.c:		display->ptr[3] = mlx_get_data_addr(display->text_ea,
display/loadtextures.c:		&(display->bpp2[3]), &(display->s_line2[3]), &(display->ed2[3]));
display/loadtextures.c:		if (display->widthtext[i] > 64 || display->heighttext[i] > 64)
display/raycasting.c:	display->index = display->r1 - 1;
display/raycasting.c:	while (display->index > 0)
display/raycasting.c:		display->camerax = 2 * display->index / (double)display->r1 - 1;
display/raycasting.c:		display->d.x = display->dirx + display->planex * display->camerax;
display/raycasting.c:		display->d.y = display->diry + display->planey * display->camerax;
display/raycasting.c:		display->index--;
display/raycasting.c:	display->mapi.x = floor(display->player.x);
display/raycasting.c:	display->mapi.y = floor(display->player.y);
display/raycasting.c:	display->deltadist.x = sqrt(1 + ((display->d.y * display->d.y) /
display/raycasting.c:				(display->d.x * display->d.x)));
display/raycasting.c:	display->deltadist.y = sqrt(1 + ((display->d.x * display->d.x) /
display/raycasting.c:				(display->d.y * display->d.y)));
display/raycasting.c:	display->stepx = (display->d.x > 0) ? 1 : -1;
display/raycasting.c:	display->stepy = (display->d.y > 0) ? 1 : -1;
display/raycasting.c:	if (display->d.x > 0)
display/raycasting.c:		display->sidedist.x = (display->mapi.x + 1 - display->player.x)
display/raycasting.c:			* display->deltadist.x;
display/raycasting.c:		display->sidedist.x = (display->player.x - display->mapi.x)
display/raycasting.c:			* display->deltadist.x;
display/raycasting.c:	if (display->d.y > 0)
display/raycasting.c:		display->sidedist.y = (display->mapi.y + 1 - display->player.y)
display/raycasting.c:			* display->deltadist.y;
display/raycasting.c:		display->sidedist.y = (display->player.y - display->mapi.y)
display/raycasting.c:			* display->deltadist.y;
display/raycasting.c:		if (((display->sidedist.y <= 0) || ((display->sidedist.x >= 0)
display/raycasting.c:						&& display->sidedist.x < display->sidedist.y)))
display/raycasting.c:			display->sidedist.x += display->deltadist.x;
display/raycasting.c:			display->mapi.x += display->stepx;
display/raycasting.c:			display->side = 0;
display/raycasting.c:			display->sidedist.y += display->deltadist.y;
display/raycasting.c:			display->mapi.y += display->stepy;
display/raycasting.c:			display->side = 1;
display/raycasting.c:		if (display->map[display->mapi.y][display->mapi.x] == '1')
display/raycasting.c:	if (display->side == 0)
display/raycasting.c:		if (display->d.x >= 0)
display/raycasting.c:			display->textnum = 3;
display/raycasting.c:			display->textnum = 2;
display/raycasting.c:		if (display->d.y >= 0)
display/raycasting.c:			display->textnum = 1;
display/raycasting.c:			display->textnum = 0;
display/raycasting.c:	if (display->side == 0)                                      // Perwalldist = distance final entre le joeur et le mur trouvÃ© (pour un rayon)
display/raycasting.c:		display->perwalldist = (display->mapi.x - display->player.x +
display/raycasting.c:				(1 - display->stepx) / 2) / display->d.x;
display/raycasting.c:		display->perwalldist = (display->mapi.y - display->player.y +
display/raycasting.c:				(1 - display->stepy) / 2) / display->d.y;
display/raycasting.c:	display->lineheight = (int)(display->r2 / display->perwalldist);     // Calcul de la hauteur du mur (plus perwalldist est grand, plus le mur est petit >raycasting)
display/raycasting.c:	display->startline = -display->lineheight / 2 + display->r2 / 2;
display/raycasting.c:	if (display->startline < 0)
display/raycasting.c:		display->startline = 0;
display/raycasting.c:	display->endline = display->lineheight / 2 + display->r2 / 2;
display/raycasting.c:	if (display->endline >= display->r2)
display/raycasting.c:		display->endline = display->r2 - 1;
display/raycasting.c:	if (display->side == 0)
display/raycasting.c:		display->wallx = display->player.y +
display/raycasting.c:		display->perwalldist * display->d.y;
display/raycasting.c:		display->wallx = display->player.x +
display/raycasting.c:		display->perwalldist * display->d.x;
display/raycasting.c:	display->wallx -= floor((display->wallx));
display/raycasting.c:	draw_line(display, display->index);
parse/checkmap.c:	if (display->map[mapy][mapx] == '9' ||
parse/checkmap.c:	display->map[mapy][mapx] == 's')
parse/checkmap.c:		if (display->map[mapy][mapx] == 's')
parse/checkmap.c:			display->map[mapy][mapx] = '2';
parse/checkmap.c:		if (display->map[mapy][mapx] == '9')
parse/checkmap.c:			display->map[mapy][mapx] = '0';
parse/checkmap.c:	if (mapy == 0 || mapy == display->mapy - 1
parse/checkmap.c:	|| mapx == 0 || mapx == display->mapx - 1)
parse/checkmap.c:	if (checkifgood(display->map[mapy + 1][mapx]) == 0)
parse/checkmap.c:	if (checkifgood(display->map[mapy - 1][mapx]) == 0)
parse/checkmap.c:	if (checkifgood(display->map[mapy][mapx + 1]) == 0)
parse/checkmap.c:	if (checkifgood(display->map[mapy][mapx - 1]) == 0)
parse/checkmap.c:	mapy = (int)display->player.x;
parse/checkmap.c:	mapx = (int)display->player.y;
parse/checkmap.c:	if (display->numberofplayer == 0)
parse/checkmap.c:	if (display->numberofplayer > 1)
parse/madebmp.c:	display->errorbool = 1;
parse/madebmp.c:	char			buffer[display->s_line];
parse/madebmp.c:	while (i < display->r2)
parse/madebmp.c:		ft_memcpy(buffer, addr + display->s_line *
parse/madebmp.c:		(display->r2 - i - 1), display->s_line);
parse/madebmp.c:		if (write(fd, &buffer, display->s_line) < display->s_line)
parse/madebmp.c:	return (display->pxl);
parse/madebmp.c:	head.file_size = (display->r1 * display->r2 * (display->bpp / 8)) + 54;
parse/madebmp.c:	head.width = display->r1;
parse/madebmp.c:	head.height = display->r2;
parse/madebmp.c:	head.bpp = display->bpp;
parse/madebmp.c:	head.img_size = display->r1 * display->r2 * (display->bpp / 8);
parse/parse.c:		display->bmp = 1;
parse/parse.c:		display->bmp = 0;
parse/parse.c:	if ((display->filename = malloc(sizeof(char)
parse/parse.c:	ft_strcpy(display->filename, str);
parse/parse.c:	display->fd = fd;
parse/parse.c:	if (display->textnum < 8)
parse/parse.c:	if (display->textnum > 8)
parse/parse.c:	if (display->mapboleen == 0)
parse/parse.c:	display->mapboleen = 0;
parse/parse.c:	display->initsuccess = 0;
parse/parse.c:	display->textnum = 0;
parse/parse.c:	display->errorbool = 0;
parse/parse.c:	display->maptofree = -1;
parse/parse.c:	display->south = NULL;
parse/parse.c:	display->north = NULL;
parse/parse.c:	display->west = NULL;
parse/parse.c:	display->east = NULL;
parse/parse.c:	display->spritepwd = NULL;
parse/parse.c:	display->filename = NULL;
parse/stockcolor.c:	display->rgbfloor[0] = ft_atoi(line);
parse/stockcolor.c:	if (display->rgbfloor[0] > 255)
parse/stockcolor.c:	display->rgbfloor[1] = ft_atoi(line + i);
parse/stockcolor.c:	if (display->rgbfloor[1] > 255)
parse/stockcolor.c:	display->rgbfloor[2] = ft_atoi(line + i);
parse/stockcolor.c:	if (display->rgbfloor[2] > 255)
parse/stockcolor.c:	display->textnum++;
parse/stockcolor.c:	display->rgbceiling[0] = ft_atoi(line);
parse/stockcolor.c:	if (display->rgbceiling[0] > 255)
parse/stockcolor.c:	display->rgbceiling[1] = ft_atoi(line + i);
parse/stockcolor.c:	if (display->rgbceiling[1] > 255)
parse/stockcolor.c:	display->rgbceiling[2] = ft_atoi(line + i);
parse/stockcolor.c:	if (display->rgbceiling[2] > 255)
parse/stockcolor.c:	display->textnum++;
parse/stockcolor.c:	display->textnum++;
parse/stockmap.c:	display->numberofplayer = 0;
parse/stockmap.c:	display->mapboleen = 1;
parse/stockmap.c:	if (display->textnum != 8)
parse/stockmap.c:	getxymap(parse, display->filename);
parse/stockmap.c:	fd = open(display->filename, O_RDONLY);
parse/stockmap.c:	display->player.x = (double)y + 0.5;
parse/stockmap.c:	display->player.y = (double)x + 0.5;
parse/stockmap.c:	display->dirx = pos == 'E' ? 1 : 0;
parse/stockmap.c:	display->dirx = pos == 'W' ? -1 : display->dirx;
parse/stockmap.c:	display->diry = pos == 'S' ? 1 : 0;
parse/stockmap.c:	display->diry = pos == 'N' ? -1 : display->diry;
parse/stockmap.c:	display->planex = (pos == 'S') ? 0.75 : 0;
parse/stockmap.c:	display->planex = (pos == 'N') ? -0.75 : display->planex;
parse/stockmap.c:	display->planey = (pos == 'W') ? 0.75 : 0;
parse/stockmap.c:	display->planey = (pos == 'E') ? -0.75 : display->planey;
parse/stockmap.c:	display->numberofplayer++;
parse/stockmap.c:		display->map[len][i] = line[i];
parse/stockmap.c:	display->map[len][i] = '\0';
parse/stockmap.c:		display->map[len][i] = ' ';
parse/stockmap.c:	display->map = malloc(sizeof(char*) * (parse->sizemap.y));
parse/stockmap.c:		display->map[i] = malloc(sizeof(char) * parse->sizemap.x + 1);
parse/stockmap.c:	display->mapx = parse->sizemap.x;
parse/stockmap.c:	display->mapy = parse->sizemap.y;
parse/stockmap.c:	display->maptofree = i;
parse/stocktexture.c:	if (display->north != NULL)
parse/stocktexture.c:	if (((display->north = malloc(sizeof(char)
parse/stocktexture.c:		display->north[l] = line[i + l];
parse/stocktexture.c:	display->north[l] = '\0';
parse/stocktexture.c:	display->textnum++;
parse/stocktexture.c:	if (display->south != NULL)
parse/stocktexture.c:	if (((display->south = malloc(sizeof(char)
parse/stocktexture.c:		display->south[l] = line[i + l];
parse/stocktexture.c:	display->south[l] = '\0';
parse/stocktexture.c:	display->textnum++;
parse/stocktexture.c:	if (display->west != NULL)
parse/stocktexture.c:	if (((display->west = malloc(sizeof(char)
parse/stocktexture.c:		display->west[l] = line[i + l];
parse/stocktexture.c:	display->west[l] = '\0';
parse/stocktexture.c:	display->textnum++;
parse/stocktexture.c:	if (display->east != NULL)
parse/stocktexture.c:	if (((display->east = malloc(sizeof(char)
parse/stocktexture.c:		display->east[l] = line[i + l];
parse/stocktexture.c:	display->east[l] = '\0';
parse/stocktexture.c:	display->textnum++;
parse/stocktexture.c:	if (display->spritepwd != NULL)
parse/stocktexture.c:	if (((display->spritepwd = malloc(sizeof(char)
parse/stocktexture.c:		display->spritepwd[l] = line[i + l];
parse/stocktexture.c:	display->spritepwd[l] = '\0';
parse/stocktexture.c:	display->textnum++;
utils/freeandexit.c:	display->errorbool = 1;
utils/freeandexit.c:	if (display->initsuccess == 1)
utils/freeandexit.c:		mlx_destroy_window(display->mlx_ptr, display->mlx_win);
utils/freeandexit.c:	if (display->south)
utils/freeandexit.c:		free(display->south);
utils/freeandexit.c:	if (display->north)
utils/freeandexit.c:		free(display->north);
utils/freeandexit.c:	if (display->west)
utils/freeandexit.c:		free(display->west);
utils/freeandexit.c:	if (display->east)
utils/freeandexit.c:		free(display->east);
utils/freeandexit.c:	if (display->spritepwd)
utils/freeandexit.c:		free(display->spritepwd);
utils/freeandexit.c:	if (display->filename)
utils/freeandexit.c:		free(display->filename);
utils/freeandexit.c:	if (display->errorbool == 0)
utils/freeandexit.c:	if (display->maptofree == -1)
utils/freeandexit.c:	while (i < display->maptofree)
utils/freeandexit.c:		free(display->map[i]);
utils/freeandexit.c:	if (display->map)
utils/freeandexit.c:		free(display->map);
utils/freeandexit.c:	width = display->r1;
utils/freeandexit.c:	height = display->r2;
utils/utils3.c:	disttemp = display->spritedist[index];
utils/utils3.c:	display->spritedist[index] = display->spritedist[index - 1];
utils/utils3.c:	display->spritedist[index - 1] = disttemp;
utils/utils3.c:	spritetemp = display->spritex[index];
utils/utils3.c:	display->spritex[index] = display->spritex[index - 1];
utils/utils3.c:	display->spritex[index - 1] = spritetemp;
utils/utils3.c:	spritetemp = display->spritey[index];
utils/utils3.c:	display->spritey[index] = display->spritey[index - 1];
utils/utils3.c:	display->spritey[index - 1] = spritetemp;
utils/utils4.c:		display->map[len][i] = '9';
utils/utils4.c:		display->map[len][i] = 's';
utils/utils4.c:		display->map[len][i] = initposplayer('N', len, i, display);
utils/utils4.c:		display->map[len][i] = initposplayer('S', len, i, display);
utils/utils4.c:		display->map[len][i] = initposplayer('E', len, i, display);
utils/utils4.c:		display->map[len][i] = initposplayer('W', len, i, display);
utils/utils4.c:		display->map[len][i] = ' ';
